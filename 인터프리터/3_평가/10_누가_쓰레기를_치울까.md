## 누가 쓰레기를 치울까

객체는 메모리에 저장되며, 객체를 많이 사용할수록 메모리도 더 많이 필요하다.

인터프리터 프로세스의 메모리 사용량(memory usage)이 증가하다보면, 언젠가는 결국 메모리가 부족해 운영체제에서 인터프리터 프로세스를 강제 종료(kill)할 것.

다만, 호스트 언어로 사용하는 Go의 가비지 컬렉터 덕분에 게스트 언어에서 별도로 가비지 컬렉션 불필요.

GC에서 접근 가능한 객체와 접근할 수 없는 객체를 추적하며, 접근할 수 없는 상태의 객체에 할당된 메모리를 자동으로 수거하여 다른 객체가 사용하도록 함.

### GC 직접 구현 방법

메모리 누수(leak)의 발생을 막아, 메모리가 부족하지 않도록 해야 하는 작업들.

1. 객체 할당(object allocations) 추적
2. 객체 참조(references to objects) 추적
3. 미래에 할당할 객체를 위한 충분한 메모리 확보
4. 필요 없는 객체에서 메모리 수거 == 가비지 컬렉션.

### GC 알고리즘 및 구현

- 마크 앤 스윕(mark and sweep) 알고리즘: 객체 참조가 발생하고 있는 객체들을 재귀적으로 탐색하여 표시(mark)한 뒤에, 표시가 없는 객체들을 모두 메모리에서 해제(sweep)하는 방법.

- Generational GC: 객체에 세대를 부여하여 추적하며, 세대별로 처리 전략과 관리 위치를 달리하는 GC.
- Stop the world GC: 가비지 컬렉션을 위해 프로그램 자체를 중지시키는 GC.
- Concurrent GC: STW와는 달리 병렬적으로 GC를 수행.

메모리의 구성 방식 & 메모리 파편화에 대한 처리도 고려 필요.
