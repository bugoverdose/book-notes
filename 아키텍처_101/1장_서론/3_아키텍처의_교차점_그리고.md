## 3 아키텍처의 교차점 그리고...

지난 10년 간 소프트웨어 아키텍처의 범위는 더 많은 책임과 관점을 아우르게 됨!

- 아키텍처와 운영의 관계는 보통 공식적인 계약으로 한정되었으며, 번거로운 행정 절차가 뒤따랐음. 회사에서의 자체 운영보다는 외주를 맡겼으며, 가동시간, 확장성, 응답성 등 아키텍처 특성을 서비스 수준 협약(SLA)로 묶어 계약 이행을 요구했음.
- ex) 탄력적 확장(elastic scale) 기능을 아키텍처에 구현하려면 과거에는 고통스러웠으나, 마이크로서비스에서는 아키텍트와 데브옵스 간에 소통을 통해 수월하게 처리할 수 있게 됨.

아키텍트와 다른 조직 부서 간의 새로운 교차점과 아키텍트의 새로운 능력 및 책임.

#### pets.com과 탄력성의 필요성

인터넷 초창기에 등장한 페츠닷컴에서 마케팅 성공으로 주문이 급증하기 시작함.

크리스마스 시즌에 특히 웹사이트의 응답속도가 느리고, 트랜잭션이 끊어지고, 배송 지연 등 증가하는 트래픽에 대응하는데 실패하여 결국 망함.

리소스 인스턴스를 필요한만큼 더 많이 가동시키는 탄력적 확장 능력이 부족했음.

- 당시에는 회사에서 직접 인프라를 관리해야 했기 때문. 결과적으로 **너무 큰 성공이 도리어 비즈니스를 죽여버리는 현상**이 종종 발생함!
- 지금은 모든 클라우드 업체가 필수적으로 제공하는 기능.

### 엔지니어링 프랙티스

과거에는 소프트웨어 아키텍처와 소프트웨어 개발 프로세스는 서로 분리되어있었음. 폭포수(waterfall) 모델, 애자일(agile) 등의 방법론은 소프트웨어 아키텍처에 영향을 미치지 못함.

- 소프트웨어 개발 `프로세스(process)`: **사람을 조직하고 상호작용하는 총체적인 기법**. 팀을 어떻게 구성 및 관리할 것인가, 회의는 어떻게 할 것인가, 워크플로우 조직은 어떻게 운영할 것인가 등.

- `엔지니어링 프랙티스(engineering practice)`: 프로세스와 무관하게 **가시적이고 반복적인 혜택을 주는 실천론**. 특정 프로세스에 의존하지 않음.
  - ex) 지속적 통합(continuous integration)

#### 익스트림 프로그래밍에서 지속적 전달까지

1990년대 초의 개발 프로세스들 중 반복적으로 좋은 결과를 내는 것은 경험상 하나도 없었음. 프로젝트 성공 여부는 확률에 따랐을 뿐.

[XP](http://www.extremeprogramming.org): 자동화, 테스팅, 지속적 통합 등 구체적이면서 경험에 기반한 여러 기법이 포함된 방법론

- 1996년도에 XP(Extreme Programing) 프로젝트가 시작됨
- 전통적인 지혜와 무관하게 실질적으로 과거에 프로젝트 성공에 효과적이었던 프랙티스를 집중적으로 분석하여, 테스트를 더 많이 하는 것과 소프트웨어 품질 간의 상호연관관계를 발견함.
- 결과적으로 테스트를 먼저 해보면서 개발, 모든 코드를 테스트한 다음에 코드베이스에 넣은 XP 방식의 프랙티스가 확립됨.

`Continuous Delivery`

- 소프트웨어 개발의 엔지니어링 측면을 발전시키려는 노력에 따라 업데이트된 XP 프랙티스가 집대상된 서적.
- 데브옵스가 태동하는 원동력이 됨.
- 자동화, 테스팅, SSOT(Single Source Of Truth; 선언적 단일 진실 공급원) 등 XP에서 주창한 엔지니어링 프랙티스를 운영자가 받아들이기 시작하면서 데브옵스 혁명이 일어남.

#### 엔지니어링 프랙티스의 중요성

1. 소프트웨어 개발 분야는 다른 엔지니어링 체계에 있는 특성들이 많이 없음. 구조 변경에 따른 결과 예측이 토목 엔지니어에 비해 어려움!

2. 소프트웨어 개발의 치명적인 약점 중 하나는 추정(estimation)의 어려움. 기본적으로 얼마나 오래 걸리고, 얼마나 많은 리소스가 필요하고, 얼마나 많은 비용이 들어갈지 내다봐야 함. **소프트웨어 시스템에서는 알려지지 않은 미지의 것들(unknown unknowns; 모른다는 점도 모르는 것들)의 존재는 필연적이므로 추측하기 더 어려워짐.** 아무도 몰랐던 것들이 갑자기 불쑥 튀어나와 미궁에 빠지기 쉬움.

- 아키텍트는 알려지지 않은 미지의 것들까지 설계할 수 없으므로 Big Design Up Front(일단 설계부터 확실하게!) 방식으로 진행하기 어려움.

> 마크(저자): 모든 아키텍처는 알려지지 않은 미지의 것들 때문에 자꾸 되풀이됨. 애자일은 단지 이것을 인지해서 더 빨리 수행하는 것이다.

- 소프트웨어 아키텍처의 속성상 반복적인 프로세스가 기본적으로 잘 맞음. 폭포수 모델은 안 맞음!

#### 아키텍처 스타일과 엔지니어링 프랙티스의 공생관계

아키텍트는 프로젝트 리더를 겸하는 경우도 많으므로 팀의 엔지니어링 프랙티스를 결정함.

아키텍트는 이때 **아키텍처 스타일과 엔지니어링 프랙티스가 서로 공생 관계망(symbiotic mesh)을 형성**하도록 하도록 해야 함! 문제 영역마다 적합한 아키텍처 스타일이 있듯이 엔지니어링 프랙티스도 동일한 종류의 공생관계를 맺음.

- ex) 마이크로서비스 아키텍처는 머신 프로비저닝(machine provisioning)과 자동화 테스팅/배포 등 많은 것들을 전제로 함.

#### Building Evolutionary Architectures

진화하는 아키텍처(evolutionary architecture)의 필요성

- 소프트웨어 개발에서 정적인 것은 하나도 없음.
- 아키텍트가 특정 기준에 맞게 시스템을 설계할 수 있지만 그 설계는 구현과 소프트웨어 개발 생태계의 어쩔 수 없는 변화를 모두 거치면서 살아남아야 함.

Neal 서적 `<Building Evolutionary Architectures>`

- 엔지니어링 프랙티스와 아키텍처의 교차점을 새로운 시각으로 바라보아야 함을 강조함.
- 아키텍처 피트니스 함수(architectural fitness function): 특정 아키텍처 특성의 객관적인 완전성을 평가하는 수단. metric(지표), unit test, monitor, chaos engineering 등의 메커니즘이 이 평가에 포함됨.

### 운영/데브옵스

과거 많은 기업들은 소프트웨어 개발과 운영은 별도 기능으로 간주. 외주를 많이 맡김.

몇 년 전 기업들에서는 운영 문제와 아키텍처를 결합한 새로운 형태의 아키텍처를 실험적으로 도입하기 시작함.

- ESB(Enterprise Service Bus) 기반의 SOA는 탄력적으로 확장할 수 있도록 설계됨에 따라 오히려 아키텍처 프로세스가 극도로 복잡했음. 확장, 성능, 탄력성 등 여러가지 기능을 내부적으로 처리할 수 있는 아키텍처를 구축하는 대신 아키텍처가 매우 복잡해지는 부작용 발생.

마이크로서비스 아키텍처 스타일을 정립한 아키텍트들은 아키텍처와 운영 간에 연결고리를 맺어 설계를 단순화시킴.

### 프로세스

"소프트웨어 아키텍처는 소프트웨어 개발 프로세스에 거의 직교적"

- 프로세스(소프트웨어 구축 방법)는 구조(소프트웨어 아키텍처)에 별다른 영향을 미치지 않음.
- 사실상 이 둘은 완전히 별개임!

모든 아키텍처는 단지 시간 문제일 뿐 반복적임. 애자일 방법론을 기반으로 하되 필요시 예외를 도출해야 함!

재구성(resturcturing)은 애자일 방법론의 진면목을 볼 수 있는 중요한 아키텍처 분야 중 하나. 아키텍처를 특정 패턴에서 다른 패턴으로 바꿔야 할 때 애자일 방법론의 촘촘한 피드백 루프, 스트랭글러 패턴, 기능 토글 등의 기법 등이 도움이 됨.

### 데이터

아키텍트와 DB 관리자는 협업하며 복잡한 시스템의 데이터 아키텍처를 구축하며, 관계 및 재사용이 애플리케이션에 미치는 영향에 대해 분석함!

아키텍처 운영 문제를 논할 때 DB는 중요한 외부 관심사

- 코드와 데이터는 공생 관계이므로 서로가 없으면 무용지물이 됨!
- RDBMS와 NoSQL 등의 외부 데이터 스토리지는 애플리케이션 개발의 큰 비중을 차지함.
