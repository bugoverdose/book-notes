# 6장 아키텍처 특성의 측정 및 거버넌스

## 아키텍처 특성 측정

아키텍처 특성을 정의할 때 아래와 같은 문제들이 존재할 수 있음. 그러나 아키텍처 특성을 **명확하고 객관적으로 정의**하면 이러한 문제들은 모두 해결됨!

- **의미가 모호**함.
  - 동일한 용어에 대한 시각과 해석은 상황에 따라 다양함.
- **정의의 다양성**.
  - "성능"과 같은 용어조차 개발자, 아키텍트, 운영자가 정의 통일 필요.
  - 객관적으로 정의하고 조직 전체가 이에 동의하면 팀은 공통의 아키텍처 언어를 확립할 수 있음!
- 복합적. 하나의 아키텍처 특성은 **복수의 다른 세부 특성들로 구성**됨.
  - 민첩성 = 모듈성, 배포성, 시험성 등으로 세분화 가능
  - 복합적인 특성을 잘게 나누어 분석해보면 객관적으로 정의/측정 가능한 특성들이 나올 수 있음!

### 운영적 측정

1. 성능, 확장성처럼 비교적 정확하게 측정가능한 아키텍처 특성이더라도 **팀 목표에 따라 다양한 해석이 가능**함!

   - ex) 성능을 평균 응답시간으로 측정하는 경우. edge case로 인해 1%의 요청이 다른 요청들에 비해 처리시간이 10배 이상 오래 걸리는 경우가 가능함.
     - 사내 리소스가 충분한 경우 이러한 outlier를 잡아내지 못할 수도 있음.
     - 최대 응답시간까지 함께 측정해야 이러한 특이점을 잡아낼 수 있음.

2. 엔지니어가 **달성하기 어려운 임의의 성능 수치를 목표로 삼는 것이 아니라! 그동안 측정된 통계 분석 결과를 토대로 목표를 수립**하는 것이 이상적!

   - 확장성을 모니터링하는 비디오 스트리밍 서비스 업체의 경우, **시간에 따라 어떤 추이를 보이는지를 측정하고 통계 모델을 수립**함. 그리고 실시간으로 수집하는 메트릭이 예측 모델에서 벗어나는 경우 알림 메시지를 보내도록 함.
   - 만일 이 과정에 문제가 생긴다면 통계 모델 자체가 부정확했거나, 무언가 이상현상이 발생한 것.

3. 도구의 발전과 이해도가 높아지면서, 팀이 측정할 수 있는 아키텍처 특성 자체가 빠르게 진화하는 중.

- 최초 컨텐츠 렌더링(First Contentful Paint; 브라우저가 DOM에서 내용물의 첫번째 비트를 렌더링하는 시점. 페이지의 로딩이 실제로 시작되는 시점), 최초 CPU 유휴(First CPU idle)과 같은 메트릭에 초점을 맞추어 모바일 기기로 접속한 유저의 성능 문제를 중점적으로 다루는 등.

#### 성능의 여러 가지 맛(flavor)

"성능"이라는 아키텍처 특성

- 많은 프로젝트들에서는 대체로 웹 애플리케이션의 요청/응답 시간 측정에 초점
  - ex) 첫 페이지의 렌더링 시간은 500ms이 최적
- 아키텍트와 데브옵스 엔지니어는 성능 예산 책정에 초점
  - ex) 페이지 다운로드에 K-weight budget을 설정 (특정 페이지에 허용된 라이브러리와 프레임워크의 최대 바이트 수)

### 구조적 측정

성능만이 아니라 모듈성과 같은 내부 구조에 관한 특성 등은 목표치가 불확실한 메트릭.

- 순환 복잡도(Cyclomatic Complexity; CC)라는 메트릭을 통해 코드의 복잡도 측정 가능.

#### 순환 복잡도

- 함수/메서드, 클래스, 애플리케이션 레벨에서 코드 복잡도를 객관적으로 나타내는 지표.
- 코드에 그래프 이론을 적용하여 계산.
- 상이한 실행 경로(execution path)를 유발하는 결정점(decision point)을 활용하여 계산.
  - 특정 함수에 if문 같은 결정문(decision statement)이 하나도 없다면 CC=1, 조건 분기가 하나 있으면 두 갈래로 나뉘므로 실행 경로는 CC=2

> CC = E - N + 2P

- 순환 복잡도를 구하는 공식
- N: node. 코드 라인
  - 실질적으로 실행되는 코드들
  - p118의 return문들 3개
- E: edge. 가능한 결정.
  - if-else문. 특정 코드 라인으로 이동시켜주는 제어문
  - p118의 if-else문들 4개
- P: connected component. 연결된 컴포넌트 수.
- 단일 함수/메서드의 순환 복잡도의 경우 P=1이므로 `CC = E - N + 2`
  - p118의 공식 적용과 그림은 틀렸음. 4-3+2=3

#### 순환 복잡도는 어느 정도가 적당한가?

너무 복잡한 코드는 곧 코드 스멜. 복잡한 코드는 모듈성, 시험성, 배포성 등 거의 모든 바람직한 코드베이스 특성을 저해하는 요소. 복잡도가 코드베이스를 장악하지 않도록 복잡도가 점점 증가하는지 잘 지켜봐야 함.

- 코드 스멜(code smell): 컴퓨터 프로그래밍 코드에서 더 심오한 문제를 일으킬 가능성이 있는 프로그램 소스코드의 특징.

1. 도메인 자체의 복잡도를 무시하면, 일반적으로 10 이하의 CC는 괜찮다고 보는 것이 업계 기준. 5이하로 나와야 응집도가 괜찮은 코드!

2. 다만, 도메인 자체의 복잡도, 문제영역의 복잡도에 따라 적정 수준의 CC 값은 매번 달라짐.

   - 알고리즘이 복잡한 문제는 그 솔루션에도 복잡한 함수가 많이 등장할 것. CC를 모니터링하는 과정에서 함수가 복잡한 이유가 문제 영역 때문인지, 코딩 품질이 낮아서인지, 코드 분할이 덜 되어서인지 등을 포괄적으로 살펴봐야 함.

cf) [Crap4j](http://www.crap4j.org): 자바 진영의 측정 도구. CC와 코드 커버리지를 함께 측정함으로써 코드가 불량한 정도 파악 가능. 코드 커버리지를 아무리 높여도 CC가 50을 넘으면 구제 불능인 코드.

#### TDD와 CC

> TDD를 실천하는 개발자는 먼저 간단한 테스트를 작성한 다음, 테스트를 통과시키는 가장 적은 양의 코드를 작성하려고 합니다. 이처럼 구체적인 동작과 명확한 테스트 경계에 집중하면 짜임새 있고 고도로 응집된 메서드를 개발할 수 있으며 그 결과 CC(Cyclomatic Complexity; 순환 복잡도) 값도 낮게 나옵니다.

### 프로세스 측정

민첩성: 소프트웨어 개발 프로세스와 연관이 있으면서, 동시에 아키텍처 구조에도 영향을 미칠 수 있는 아키텍처 특성

- 소프트웨어 개발 프로세스와 교차하는 아키텍처
- 시험성, 배포성 등의 특성으로 다시 재분류되는 복합적인 아키텍처 특성

시험성과 배포 용이성을 추구하는 경우, 아키텍처 수준에서 모듈성/격리성을 높이는 것을 추구 => 즉, 아키텍처 특성이 구조를 주도하게 됨.

#### 시험성

시험성: 테스트의 완전성을 평가하는 커버리지 도구로 측정 가능 => 객관적으로 측정 가능

- 물론 코드 커버리지가 100%여도 코드의 정확성에 신뢰감을 부여하는 assertion이 형편없는 테스트도 존재 가능.
- 측정 도구만으로는 물론 thinking과 의도를 대체할 수는 없기 때문.

#### 배포성

배포성: 실패 대비 배포 성공률(%), 배포 소요 시간, 배포시 발생한 이슈/버그 등의 메트릭으로 객관적인 측정 가능.

- 양적/질적으로 조직에 유용한 데이터를 포착하기 위한 측정 세트는 별도로 준비하긴 해야 함.
