### 커네이선스(connascence)

커네이선스(connascence): 변화 종속성. 어느 한쪽을 바꾸면 다른 쪽도 함께 바꾸어야 전체적으로 정합성이 유지되는 상태.

- 밀러 페이지-존스의 `<What Every Programmer Should Know About Object-Oriented Design>(1996)`에서 등장한 개념.
- 구심/원심 커플링 메트릭을 더욱 발전시킨 개념을 객체지향언어의 화두로 던짐.
- 커네이선스를 정적 커네이선스와 동적 커네이선스로 분류.

> Meilir Page-Jones: **두 컴포넌트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 시스템의 정합성이 맞는다면** 이들은 커네이선스를 갖고 있는 것이다.

#### 정적 커네이선스(static connascence)

정적 커네이선스는 소스코드 레벨의 커플링. 구심/원심 커플링을 발전시킨 개념.

- `명칭 커네이선스(CoN)`: 여러 컴포넌트의 **엔티티명이 일치**해야 하는 경우.

  - 일관된 메서드명은 코드베이스가 커플링되는 가장 일반적이면서 바람직한 방법. IDE에서 시스템 전체적으로 이름을 변경하는 기능 지원.

- `타입 커네이선스(CoT)`: 여러 컴포넌트의 **엔티티 타입이 일치**해야 하는 경우.

  - 정적 타입 언어에서 변수와 매개변수를 특정 타입으로 제한하는 일반적인 기능. 클로저(Clojure) 등 선택적 타이핑(selective typing)을 제공하는 동적 타입 언어도 있음.

- `의미 커네이선스(CoM)` 또는 `관례 커네이선스(CoC)`: 여러 컴포넌트에 걸쳐 **특정 값의 의미가 일치**해야 하는 경우.

  - 숫자를 하드코딩해서 사용하는 코드베이스 등에서 주로 발견됨.

- `위치 커네이선스(CoP)`: 여러 컴포넌트에서 **값의 순서가 일치**해야 하는 경우.

  - `void update(String name, String location)`처럼 정적 타이핑이 가능하더라도 메서드/함수 호출시 전달하는 매개변수의 순서를 맞춰야 하는 경우.

- `알고리즘 커네이선스(CoA)`: 여러 컴포넌트에서 **특정 알고리즘이 일치**해야 하는 경우.

  - 서버/클라이언트에서 동일한 결과를 내야 하는 보안 해시 알고리즘은 커플링이 심함. 한쪽의 로직이 변경되면 인증 과정 성립 불가.

#### 동적 커네이선스(dynamic connascence)

동적 커네이선스는 런타임 호출을 분석하는 커네이선스. 다만, 런타임 호출에 대한 효과적인 분석 도구가 많지 않아 **동적 커네이선스는 상대적으로 아키텍트가 파악하기** 어려움!

- `실행 커네이선스(CoE)`: 여러 컴포넌트의 **실행 순서**가 중요한 경우.

  - setter 호출로 프로퍼티를 전부 셋팅한 이후에 프로퍼티를 사용하는 메서드를 호출해야 하는 등.

- `시점 커네이선스(CoT)`: 여러 컴포넌트의 **실행 시점**이 중요한 경우.

  - 동시에 실행 중인 두 쓰레드 사이에 race condition이 발생하여 결과에 영향을 미치는 등.

- `값 커네이선스(CoV)`: **상호 연관된 다수의 값들을 함께 변경**할 때 발생.

  - 분산 시스템의 트랜잭션. 데이터베이스가 분리된 시스템에서 모든 DB에서 하나의 값을 수정해야 하는 경우 전체 값을 모두 변경하거나, 아무 값도 변경하지 말아야 함.

- `식별 커네이선스(CoI)`: 여러 컴포넌트에서 **동일한 엔티티를 참조**할 때 발생.

  - 독립적인 두 컴포넌트가 분산 큐(distributed queue)를 공유하여 업데이트하는 등

#### 커네이선스 속성

커네이선스는 아키텍트와 개발자에게 도움이 되는 분석 도구로 다음 속성들을 활용할 수 있음.

- `커네이선스 강도(strength)`

  - 커네이선스의 유형에 따른 리팩터링의 용이한 정도.
  - 더 강한 커네이선스로 리팩터링을 진행하여 커플링 개선 가능.
  - **동적 -> 정적 커네이선스 방향**으로 리팩터링 진행.
  - 정적 커네이선스는 개발자가 소스코드를 분석하고 IDE를 활용함으로써 쉽게 개선 가능하므로 동적 커네이선스보다 선호됨.
  - **아이덴티티 -> 값 -> 타이밍 -> 실행 -> 위치 -> 알고리즘 -> 의미 -> 타입 -> 명칭 방향**으로 리팩터링 진행.
    - 의미 커네이선스 => 명칭 커네이선스로의 개선 예시: magic value의 의미를 알 수 있도록 기명 상수로 정의.

- `커네이선스의 지역성(locality)`

  - 코드베이스의 모듈들이 서로 얼마나 가까이 있는가.
  - **근접한 코드(proximal code)**는 별개의 모듈/코드베이스로 분리된 코드보다 대체로 **더 높은 형태의 커네이선스**를 지님.
  - 모듈을 서로 가까이 붙여놓는 방식으로 커플링 개선 가능.

- `커네이선스 정도(degree)`

  - 커네이선스가 미치는 영향의 규모. 얼마나 더 적은 클래스들에 영향을 미치는가.
  - 커네이선스의 정도가 낮을수록 이상적인 코드베이스.

#### 커네이선스 활용법

페이지-존스가 제안한 시스템의 모듈성을 개선하기 위한 3가지 커네이선스 활용법

1. 시스템을 캡슐화한 요소들로 분리해 **전체 커네이선스 최소화**.
2. 캡슐화 경계를 벗어나는 커네이선스는 전부 **최소화**.
3. 캡슐화 경계 내부에서 커네이선스 **최대화**.

짐 웨이리치(Jim Weirich)의 두 가지 조언

- 정도의 규칙(Rule of Degree): 강한 형태의 커네이선스를 보다 약한 형태의 커네이선스로 전환하라.
- 지역성의 규칙(Rule of Locality): 소프트웨어 요소 간의 거리가 멀어질수록 보다 약한 형태의 커네이선스를 사용하라.
