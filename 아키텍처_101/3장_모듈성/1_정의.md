## 정의

모듈성(modularity)의 사전적 정의: `복잡한 구조를 만드는 데 쓰이는 각각의 표준화된 부품 및 독립적인 단위`

- 개발자는 `서로 연관된 코드를 함께 묶는 수단`으로 모듈을 사용함.

**아키텍트는 개발자가 코드를 어떻게 패키징하는지 반드시 알아야 함**.

여러 패키지가 `서로 단단히 커플링되어 있으면 그 중 하나를 다른 작업에 재사용하기 어려워지는 등` 이는 **아키텍처에 중요한 영향을 미침**!

### 모듈성과 물리적인 분리

모듈성은 특정 플랫폼에 함축되어있거나, 불가피한 물리적인 분리와는 별개의 개념.

- 아키텍처를 논할 때 클래스, 함수처럼 코드를 묶어놓은 덩어리를 모듈성으로 표현하는 것은 논리적인 구분이지 물리적인 구분이 아님.
- 모놀리틱 애플리케이션에서는 많은 클래스를 하나의 덩어리로 묶어도 무관하지만, MSA로 나아갈려고 할 때 이처럼 커플링된 구조가 문제가 될 수 있음.

개발자는 상이한 컴포넌트, 클래스 등의 소프트웨어 자산을 서로 구분하기 위해 정확한 완전 정규화 명칭(FQN)을 필요로 함.

닷넷 플랫폼에는 namespace 개념이 존재함.

대부분의 언어에도 변수, 함수, 메서드 등을 구성하는 데 필요한 네임스페이스 역할을 하는 모듈성 메커니즘이 존재함.

자바에서는 모듈 구조가 물리적으로 반영됨. 패키지 구조가 실제로 클래스 파일의 물리적인 디렉터리 구조를 그대로 나타냄.

### 클래스 이전 시절의 모듈 재사용

1968년에 다익스트라의 `Go To Statement Considered Harmful`이라는 논문에서 당시 프로그래밍 언어에서 GOTO문이 남용된 까닭에 로직을 이해하기 어려웠던 점을 지적함! (코드 내의 비선형적인 흐름이 잦았음)

이에 따라 Pascal과 C 언어로 대표되는 `구조적 프로그래밍 언어(structured programming language)`의 시대가 열리며, 코드를 어떻게 서로 연결하면 좋을지 깊이 생각해보는 계기가 됨.

- 잠시동안 모듈라(Modula)와 아다(Ada)와 같이 '모듈'이라는 프로그래밍 요소를 지닌 `모듈러 언어(modular language)`가 잠시 번성함. 모듈은 패키지 및 네임스페이스와 거의 유사한 기능.

이후 코드를 캡슐화하여 재사용하는 새로운 지평을 연 **객체지향언어**가 인기를 끌게 되었을 때에도 모듈이란 개념은 패키지, 네임스페이스 등의 형태로 존속됨!

프로그래밍 언어에서 상이한 패러다임을 지원하기 위해 호환성 기능을 추가하는 경우는 흔함.

- 자바에서 패키지, 정적 생성자를 이용한 패키지 레벨의 인스턴스화를 통해 모듈화를 제공하거나, 객체지향, 함수형 패러다임을 지원하는 이유는 개발자가 생각하는 방식에 관한 하위호환성(backward compatibility)을 제공하기 위함.
- 모듈라 언어에서 지원하는 모듈이란 개념을 다른 언어들에서 패키지, 네임스페이스 등의 형태로 도입.

### 모듈성 및 패키징 메커니즘

- 이제는 프로그래밍 언어에서 제공하는 모듈성 메커니즘과 패키징 메커니즘이 워낙 다양해짐.

  - 대부분의 프로그래밍 언어는 모듈성 메커니즘을 제공. 자바의 package, 닷넷의 namespace처럼 등
  - 프로그래밍 언어에 내장된 패키징 메커니즘도 다양해짐에 따라 개발자가 하나를 선택하는 것도 힘들어짐.
    - 언어마다 가시성과 스코핑 규칙이 다른 함수/메서드, 클래스, 패키지/네임스페이스를 개발자가 정의 가능.
    - [메타오브젝트 프로토콜(metaobject protocol)](https://en.wikipedia.org/wiki/Metaobject) 같은 요소를 통해 개발자에게 다양한 확장 메커니즘을 제공하는 언어도 존재함.

### 이름 충돌이 없는 언어, 자바 1.0

자바 1.0에서는 **이름이 동일한 클래스들 간의 모호함(ambiguity)을 방지**하기 위해 **패키지명과 물리적인 디렉터리 구조를 일치시키도록 강제**하는 패키지/네임스페이스 메커니즘을 도입함.

- 동일한 디렉터리에 동명의 파일이 여러 개 존재할 수 없는 운영체제 파일시스템의 특성을 활용한 것.

문제는 자바의 두 번째 메이저 릴리즈 버전(자바 1.2)에서 JAR 메커니즘을 추가하여 아카이브 파일이 클래스패스에서 디렉터리 구조 역할을 하도록 허용함.

- 모든 프로젝트가 완전한 형태의 디렉터리 구조를 갖도록 강제하는 것이 어려웠기 때문.
- 결과적으로 개발자들은 이후 10년 간 디렉터리와 JAR 파일을 조합하여 클래스패스를 정확히 맞추기 위해 노력해야했으며, 클래스패스에서 두 JAR 파일명이 충돌하는 경우는 막을 길이 없어 클래스로더를 디버깅하는 일까지 일어나게 됨.
