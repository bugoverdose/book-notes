# 7장 아키텍처 특성 범위

10년 전 대부분의 시스템이 모노리틱이던 시절, 아키텍처 특성의 범위를 시스템 레벨에 두는 것이 당연했음.

현재는 마이크로서비스 등의 아키텍처 스타일이 가능해지면서 아키텍처 특성의 범위는 상당히 좁혀짐.

아키텍트는 운영 아키텍처 특성을 따져보고 **아키텍처 특성에 영향을 미치는 코드베이스 외부의 컴포넌트**를 잘 살펴봐야 함.

- 6.1.2절에서는 아키텍처의 구조적 측면을 분석할 수 있는 코드 레벨의 메트릭을 소개함. 그러나 이는 코드에 관한 저수준의 메트릭일 뿐.
- 운영과 관련된 아키텍처 특성에 영향을 미치는, 코드베이스 외부의 의존성(ex. DB)을 지닌 컴포넌트는 평가 불가!
  - 아키텍트가 성능 좋고 탄력적인 코드베이스를 설계하려고 아무리 노력해도 시스템이 그런 특성에 부합하지 않는 DB를 사용하면 애플리케이션은 성공 불가

이런 종류의 의존성을 측정하기 위해 Building Evolutionary Architectures의 저자들은 아키텍처 퀀텀(architecture quantum)이라는 용어를 정의함.

## 커플링과 커네이선스

`아키텍처 퀀텀`의 정의를 위해서는 **커네이선스 개념을 통해 컴포넌트들이 어떻게 서로 연결되어 있는지(wired) 측정**할 필요가 있음.

1.  구심/원심 결합도(3.2.2 참고)와 같은 코드 레벨의 커플링 메트릭은 아키텍처 분석용으로는 너무 세분도(granularity)가 높은 편.

- 이 때문에 밀러 페이지-존스는 **새로운 커플링 메트릭으로 커네이선스를 소개**함!

> 두 컴포넌트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 시스템의 정합성이 맞는다면 이들은 커네이선스를 같고 있는 것이다.

2. 밀러 페이지-존스가 소개한 두 종류의 커네이선스

- 정적 커네이선스: 정적 코드 분석으로 발견 가능.

  - ex) 마이크로서비스 아키텍처의 두 서비스가 특정 클래스를 공유하는 경우, 두 서비스는 서로 정적인 커네이선스를 지님! 해당 공유 클래스를 변경하면 두 서비스 모두 변경 필요!

- 동적 커네이선스: 런타임 동작과 관련. 동기 & 비동기로 다시 분류됨.
  - 분산 서비스끼리 **동기 호출**을 하는 경우, 호출부(caller)는 피호출부(callee)의 응답을 기다려야 함.
  - **이벤트 기반 아키텍처의 비동기 호출**은 `fire-and-forget` 방식이므로 운영 아키텍처에서 두 서비스는 개별적으로 작동시킬 수 있음. (피호출부의 응답을 기다리지 않아도 되는 방식)
