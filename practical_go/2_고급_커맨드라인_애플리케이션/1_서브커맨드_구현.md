## 1 서브커맨드 구현

서브커맨드(sub-command): 커맨드라인 애플리케이션을 독립적인 별도의 커맨드, 옵션, 인수를 지니도록 분리하는 방법

- 서로 연관 없는 기능을 분리하여 구현하는 방법

예시

- 최상위 계층(top-level)의 루트커맨드: `go`
- 서브커맨드: `go build`, `go fmt`, `go test`

구현: 각 서브커맨드마다 별도의 `FlagSet` 객체를 생성하고, 어떤 서브커맨드가 지정되었는지에 따라 부합하는 `FlagSet` 객체를 사용하여 커맨드라인 인수 파싱

- 메인 애플리케이션은 커맨드라인 인수를 보고 알맞은 서브커맨드 핸들러를 호출

### 예시 구현

1_sub_cmd_example

서브커맨드 `cmd-a`, `cmd-b` 구현. 첫 번째 위치인수로 서브커맨드 여부 확인.

- 복습) `os.Args[0]`는 프로그램명, `os.Args[1]`부터 프로그램이 실행되면서 넘겨받은 인자들

```go
func main() {
	var err error
    // 위치 인수 전달하지 않은 경우
	if len(os.Args) < 2 {
		printUsage(os.Stdout)
		os.Exit(1)
	}
    // 서브커맨드에 따른 분기
	switch os.Args[1] {
	case "cmd-a":
		err = handleCmdA(os.Stdout, os.Args[2:])
	case "cmd-b":
		err = handleCmdB(os.Stdout, os.Args[2:])
    // 최상위 계층의 루트커맨드
	default:
		printUsage(os.Stdout)
	}

	if err != nil {
		fmt.Fprintln(os.Stdout, err)
		os.Exit(1)
	}
}
```

```go
func handleCmdA(w io.Writer, args []string) error {
	var v string
	fs := flag.NewFlagSet("cmd-a", flag.ContinueOnError)
	fs.SetOutput(w)
	fs.StringVar(&v, "verb", "argument-value", "Argument 1")
	err := fs.Parse(args)
	if err != nil {
		return err
	}
	fmt.Fprintf(w, "Executing command A")
	return nil
}

func handleCmdB(w io.Writer, args []string) error {
	var v string
	fs := flag.NewFlagSet("cmd-b", flag.ContinueOnError)
	fs.SetOutput(w)
	fs.StringVar(&v, "verb", "argument-value", "Argument 1")
	err := fs.Parse(args)
	if err != nil {
		return err
	}
	fmt.Fprintf(w, "Executing command B")
	return nil
}

func printUsage(w io.Writer) {
	fmt.Fprintf(w, "Usage: %s [cmd-a|cmd-b] -h\n", os.Args[0])
    // 각 서브커맨드의 사용법 메시지 출력을 위해 -h 옵션 넘기면서 핸들러 함수 호출
	handleCmdA(w, []string{"-h"})
	handleCmdB(w, []string{"-h"})
}
```

실행 예시

```bash
./application -h
Usage: ./application [cmd-a|cmd-b] -h
Usage of cmd-a:
  -verb string
        Argument 1 (default "argument-value")
Usage of cmd-b:
  -verb string
        Argument 1 (default "argument-value")
```

```bash
./application cmd-a
Executing command A

./application cmd-b
Executing command B
```

---

### 서브커맨드 주도 애플리케이션 아키텍처
